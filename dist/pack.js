/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EPSILON\": () => /* binding */ EPSILON,\n/* harmony export */   \"ARRAY_TYPE\": () => /* binding */ ARRAY_TYPE,\n/* harmony export */   \"RANDOM\": () => /* binding */ RANDOM,\n/* harmony export */   \"setMatrixArrayType\": () => /* binding */ setMatrixArrayType,\n/* harmony export */   \"toRadian\": () => /* binding */ toRadian,\n/* harmony export */   \"equals\": () => /* binding */ equals\n/* harmony export */ });\n/**\r\n * Common utilities\r\n * @module glMatrix\r\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nvar RANDOM = Math.random;\n/**\r\n * Sets the type of array used when creating new vectors and matrices\r\n *\r\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\r\n */\n\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\r\n * Convert Degree To Radian\r\n *\r\n * @param {Number} a Angle in Degrees\r\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\r\n * Tests whether or not the arguments have approximately the same value, within an absolute\r\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\r\n * than or equal to 1.0, and a relative tolerance is used for larger values)\r\n *\r\n * @param {Number} a The first number to test.\r\n * @param {Number} b The second number to test.\r\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};\n\n//# sourceURL=webpack://fractals/./node_modules/gl-matrix/esm/common.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => /* binding */ create,\n/* harmony export */   \"clone\": () => /* binding */ clone,\n/* harmony export */   \"length\": () => /* binding */ length,\n/* harmony export */   \"fromValues\": () => /* binding */ fromValues,\n/* harmony export */   \"copy\": () => /* binding */ copy,\n/* harmony export */   \"set\": () => /* binding */ set,\n/* harmony export */   \"add\": () => /* binding */ add,\n/* harmony export */   \"subtract\": () => /* binding */ subtract,\n/* harmony export */   \"multiply\": () => /* binding */ multiply,\n/* harmony export */   \"divide\": () => /* binding */ divide,\n/* harmony export */   \"ceil\": () => /* binding */ ceil,\n/* harmony export */   \"floor\": () => /* binding */ floor,\n/* harmony export */   \"min\": () => /* binding */ min,\n/* harmony export */   \"max\": () => /* binding */ max,\n/* harmony export */   \"round\": () => /* binding */ round,\n/* harmony export */   \"scale\": () => /* binding */ scale,\n/* harmony export */   \"scaleAndAdd\": () => /* binding */ scaleAndAdd,\n/* harmony export */   \"distance\": () => /* binding */ distance,\n/* harmony export */   \"squaredDistance\": () => /* binding */ squaredDistance,\n/* harmony export */   \"squaredLength\": () => /* binding */ squaredLength,\n/* harmony export */   \"negate\": () => /* binding */ negate,\n/* harmony export */   \"inverse\": () => /* binding */ inverse,\n/* harmony export */   \"normalize\": () => /* binding */ normalize,\n/* harmony export */   \"dot\": () => /* binding */ dot,\n/* harmony export */   \"cross\": () => /* binding */ cross,\n/* harmony export */   \"lerp\": () => /* binding */ lerp,\n/* harmony export */   \"hermite\": () => /* binding */ hermite,\n/* harmony export */   \"bezier\": () => /* binding */ bezier,\n/* harmony export */   \"random\": () => /* binding */ random,\n/* harmony export */   \"transformMat4\": () => /* binding */ transformMat4,\n/* harmony export */   \"transformMat3\": () => /* binding */ transformMat3,\n/* harmony export */   \"transformQuat\": () => /* binding */ transformQuat,\n/* harmony export */   \"rotateX\": () => /* binding */ rotateX,\n/* harmony export */   \"rotateY\": () => /* binding */ rotateY,\n/* harmony export */   \"rotateZ\": () => /* binding */ rotateZ,\n/* harmony export */   \"angle\": () => /* binding */ angle,\n/* harmony export */   \"zero\": () => /* binding */ zero,\n/* harmony export */   \"str\": () => /* binding */ str,\n/* harmony export */   \"exactEquals\": () => /* binding */ exactEquals,\n/* harmony export */   \"equals\": () => /* binding */ equals,\n/* harmony export */   \"sub\": () => /* binding */ sub,\n/* harmony export */   \"mul\": () => /* binding */ mul,\n/* harmony export */   \"div\": () => /* binding */ div,\n/* harmony export */   \"dist\": () => /* binding */ dist,\n/* harmony export */   \"sqrDist\": () => /* binding */ sqrDist,\n/* harmony export */   \"len\": () => /* binding */ len,\n/* harmony export */   \"sqrLen\": () => /* binding */ sqrLen,\n/* harmony export */   \"forEach\": () => /* binding */ forEach\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\r\n * 3 Dimensional Vector\r\n * @module vec3\r\n */\n\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec3 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec3} a vector to clone\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\n\nfunction fromValues(x, y, z) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Copy the values from one vec3 to another\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the source vector\r\n * @returns {vec3} out\r\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Set the components of a vec3 to the given values\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} out\r\n */\n\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Adds two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\r\n * Multiplies two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\r\n * Divides two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to ceil\r\n * @returns {vec3} out\r\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to floor\r\n * @returns {vec3} out\r\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to round\r\n * @returns {vec3} out\r\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\r\n * Scales a vec3 by a scalar number\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec3} out\r\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\r\n * Adds two vec3's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec3} out\r\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Calculates the squared length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Negates the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to negate\r\n * @returns {vec3} out\r\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to invert\r\n * @returns {vec3} out\r\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\r\n * Computes the cross product of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\nfunction cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\r\n * Performs a hermite interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Performs a bezier interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec3} out\r\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;\n  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\r\n * Transforms the vec3 with a quat\r\n * Can also be used for dual quaternions. (Multiply it with the real part)\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\n\nfunction transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\nfunction rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {ReadonlyVec3} a The first operand\r\n * @param {ReadonlyVec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\nfunction angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\r\n * Set the components of a vec3 to zero\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @returns {vec3} out\r\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec3} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nfunction str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\r\n * Alias for {@link vec3.subtract}\r\n * @function\r\n */\n\nvar sub = subtract;\n/**\r\n * Alias for {@link vec3.multiply}\r\n * @function\r\n */\n\nvar mul = multiply;\n/**\r\n * Alias for {@link vec3.divide}\r\n * @function\r\n */\n\nvar div = divide;\n/**\r\n * Alias for {@link vec3.distance}\r\n * @function\r\n */\n\nvar dist = distance;\n/**\r\n * Alias for {@link vec3.squaredDistance}\r\n * @function\r\n */\n\nvar sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec3.length}\r\n * @function\r\n */\n\nvar len = length;\n/**\r\n * Alias for {@link vec3.squaredLength}\r\n * @function\r\n */\n\nvar sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack://fractals/./node_modules/gl-matrix/esm/vec3.js?");

/***/ }),

/***/ "./src/generalVert.vs":
/*!****************************!*\
  !*** ./src/generalVert.vs ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"attribute vec2 position;\\r\\nvarying vec2 surf_pos;\\r\\nuniform vec2 screen_ratio;\\r\\nvoid main()\\r\\n{\\r\\n    surf_pos = position * screen_ratio;\\r\\n    gl_Position = vec4(position, 0, 1);\\r\\n}\");\n\n//# sourceURL=webpack://fractals/./src/generalVert.vs?");

/***/ }),

/***/ "./src/mandleFrag.fs":
/*!***************************!*\
  !*** ./src/mandleFrag.fs ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"#ifdef GL_ES\\r\\nprecision highp float;\\r\\n#endif\\r\\n\\r\\nuniform vec3 playerPos;\\r\\nuniform vec3 playerFwd;\\r\\nuniform vec3 playerRight;\\r\\nuniform vec3 playerUp;\\r\\nuniform vec2 resolution;\\r\\n\\r\\nuniform float fixed_radius;\\r\\nuniform float min_radius;\\r\\nuniform float folding_limit;\\r\\nuniform float scale;\\r\\nuniform int shadow_count;\\r\\nuniform float detail;\\r\\n\\r\\nfloat scaleEpsilon=.001;\\r\\nvoid sphere_fold(inout vec3 z,inout float dz){\\r\\n    float r2=dot(z,z);\\r\\n    if(r2<min_radius){\\r\\n        float temp=(fixed_radius/min_radius);\\r\\n        z*=temp;\\r\\n        dz*=temp;\\r\\n    }else if(r2<fixed_radius){\\r\\n        float temp=(fixed_radius/r2);\\r\\n        z*=temp;\\r\\n        dz*=temp;\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid box_fold(inout vec3 z,inout float dz){\\r\\n    z=clamp(z,-folding_limit,folding_limit)*2.-z;\\r\\n}\\r\\n\\r\\nvec2 mb(vec3 z){\\r\\n    vec3 offset=z;\\r\\n    float dr=1.;\\r\\n    float surface = 0.;\\r\\n    vec3 colOff = vec3(0,0,0);\\r\\n    float oldDist = dot(z-colOff,z-colOff);\\r\\n    for(int n=0;n<15;++n){\\r\\n        box_fold(z,dr);\\r\\n        sphere_fold(z,dr);\\r\\n\\r\\n        oldDist = min(oldDist, dot(z-colOff,z-colOff));\\r\\n        \\r\\n        z=scale*z+offset;\\r\\n        dr=dr*abs(scale)+1.;\\r\\n    }\\r\\n    surface = oldDist;\\r\\n    float r=length(z);\\r\\n    return vec2(r/abs(dr),surface);\\r\\n}\\r\\n\\r\\nvec3 HsvToRgb (vec3 c)\\r\\n{\\r\\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\\r\\n}\\r\\n\\r\\nvec4 ObjCol (vec3 p)\\r\\n{\\r\\n  vec3 p3, col;\\r\\n  float pp, ppMin, cn, s;\\r\\n  p = mod (p + 3., 6.) - 3.;\\r\\n  p3 = p;\\r\\n  cn = 0.;\\r\\n  ppMin = 1.;\\r\\n  for (float j = 0.; j < 10.; j ++) {\\r\\n    p3 = 2. * clamp (p3, -1., 1.) - p3;\\r\\n    pp = dot (p3, p3);\\r\\n    if (pp < ppMin) {\\r\\n      cn = j;\\r\\n      ppMin = pp;\\r\\n    }\\r\\n    p3 = 2.8 * p3 / clamp (pp, 0.25, 1.) + p;\\r\\n  }\\r\\n  s = mod (cn, 2.);\\r\\n  col = HsvToRgb (vec3 (mod (0.6 + 1.5 * cn / 10., 1.), mix (0.6, 0., s), 1.));\\r\\n  return vec4 (col, 0.05 + 0.4 * s);\\r\\n}\\r\\n\\r\\nvec2 map(in vec3 rayP)\\r\\n{\\r\\n    return mb(rayP);\\r\\n}\\r\\n\\r\\nvec3 intersect(in vec3 ro,in vec3 rd,in float maxdist)\\r\\n{\\r\\n    float dist=0.;\\r\\n    for(int i=0;i<100;i++)\\r\\n    {\\r\\n        vec3 rayP=ro+dist*rd;\\r\\n        vec2 mapData=map(rayP);\\r\\n        if(mapData.x<(scaleEpsilon*dist+detail)||dist>maxdist){\\r\\n            return vec3(dist,i,mapData.y);\\r\\n        }\\r\\n        dist+=mapData.x;\\r\\n    }\\r\\n    return vec3(dist,100,-1);\\r\\n}\\r\\n\\r\\nvec3 colorRamp(float c)\\r\\n{\\r\\n    // float f=2.*c-1.;\\r\\n    // if(c<.5){\\r\\n    //     f=2.*c;\\r\\n    //     return(1.-f)*vec3(.843,.098,.1098)+f*vec3(.996,.988,.737);\\r\\n    // }\\r\\n    // return(1.-f)*vec3(.996,.988,.737)+f*vec3(.192,.529,.721);\\r\\n    // float f=2.*c-1.;\\r\\n    // if(c<.5){\\r\\n    //     f=2.*c;\\r\\n    //     return(1.-f)*vec3(42./255.,157./255.,143./255.)+f*vec3(233./255.,196./255.,107./255.);\\r\\n    // }\\r\\n    // return(1.-f)*vec3(233./255.,196./255.,107./255.)+f*vec3(231./255.,111./255.,81./255.);\\r\\n    float f=2.*c-1.;\\r\\n    if(c<.5){\\r\\n        f=2.*c;\\r\\n        return(1.-f)*vec3(219./255.,80./255.,65./255.)+f*vec3(242./255.,226./255.,93./255.);\\r\\n    }\\r\\n    return(1.-f)*vec3(242./255.,226./255.,93./255.)+f*vec3(71./255.,144./255.,227./255.);\\r\\n}\\r\\n\\r\\n//not mine------\\r\\nfloat softshadow(vec3 ro,vec3 rd,float k){\\r\\n    float akuma=1.,h=0.;\\r\\n    float t=.01;\\r\\n    for(int i=0;i<50;++i){\\r\\n        if(i>=shadow_count){\\r\\n            return akuma;\\r\\n        }\\r\\n        h=map(ro+rd*t).x;\\r\\n        if(h<.001)return.02;\\r\\n        akuma=min(akuma,k*h/t);\\r\\n        t+=clamp(h,.01,2.);\\r\\n    }\\r\\n    return akuma;\\r\\n}\\r\\n//---------------\\r\\n\\r\\nvec3 calcNormal(vec3 p,float e){\\r\\n    return normalize(vec3(\\r\\n            map(vec3(p.x+e,p.y,p.z)).x-map(vec3(p.x-e,p.y,p.z)).x,\\r\\n            map(vec3(p.x,p.y+e,p.z)).x-map(vec3(p.x,p.y-e,p.z)).x,\\r\\n            map(vec3(p.x,p.y,p.z+e)).x-map(vec3(p.x,p.y,p.z-e)).x\\r\\n        ));\\r\\n    }\\r\\n    \\r\\n    vec3 render(in vec3 ro,in vec3 rd,bool effect)\\r\\n    {\\r\\n        vec3 light=vec3(1,-1,1);//point at player for backlit effect\\r\\n        vec3 rayData=intersect(ro,rd,1024.);\\r\\n        float dist=rayData.x;\\r\\n        \\r\\n        vec3 skyColor=vec3(.91,.91,.76);\\r\\n        vec3 solidColor=pow(colorRamp(rayData.z/5.),vec3(1));\\r\\n        //vec3 solidColor=color(ro+dist*rd,dist);\\r\\n       // vec3 solidColor = ObjCol(ro + dist*rd).xyz;\\r\\n        if(rayData.x>1024.||rayData.z<0.){\\r\\n            return skyColor;\\r\\n        }\\r\\n        \\r\\n        vec3 normal=calcNormal(ro+dist*rd,scaleEpsilon*dist+detail);\\r\\n        \\r\\n        float distOcclusion=1.-rayData.y*2./200.;//hacky occlusion, more occlusion means higher number\\r\\n        float diffuseLighting=1.-clamp(dot(light,normal),0.,1.);\\r\\n        \\r\\n        float shadow=softshadow(ro+dist*rd,-light,10.);\\r\\n        float combinedShading=diffuseLighting*.3+distOcclusion*.2+.3*shadow+.2;\\r\\n        return solidColor*combinedShading;\\r\\n    }\\r\\n    \\r\\n    void main(void)\\r\\n    {\\r\\n        vec2 screenPos=-1.+2.*gl_FragCoord.xy/resolution.xy;// screenPos can range from -1 to 1\\r\\n        screenPos.x*=resolution.x/resolution.y;\\r\\n        \\r\\n        vec3 ro=playerPos;\\r\\n        vec3 rd=normalize(playerFwd+playerRight*screenPos.x+playerUp*-screenPos.y);\\r\\n        vec3 col=render(ro,rd,screenPos.x>0.);\\r\\n        gl_FragColor=vec4(col,1.);\\r\\n    }\");\n\n//# sourceURL=webpack://fractals/./src/mandleFrag.fs?");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _generalVert_vs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generalVert.vs */ \"./src/generalVert.vs\");\n/* harmony import */ var _mandleFrag_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mandleFrag.fs */ \"./src/mandleFrag.fs\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/vec3.js\");\n\r\n\r\n\r\n\r\nvar lastX, lastY, mouseDown = false;\r\nvar yawAngle = 0, pitchAngle = 0;\r\nvar playerPos = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 0, -4);\r\nvar time = 0;\r\nvar move = [0, 0, 0];\r\nvar speed = 3;\r\n\r\nvar canvas = document.getElementById(\"canvas\");\r\ncanvas.width = canvas.clientWidth;\r\ncanvas.height = canvas.clientHeight;\r\nvar gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\nvar vShader = gl.createShader(gl.VERTEX_SHADER);\r\nvar fShader = gl.createShader(gl.FRAGMENT_SHADER);\r\ngl.shaderSource(vShader, _generalVert_vs__WEBPACK_IMPORTED_MODULE_0__.default);\r\ngl.shaderSource(fShader, _mandleFrag_fs__WEBPACK_IMPORTED_MODULE_1__.default);\r\ngl.compileShader(vShader);\r\ngl.compileShader(fShader);\r\nvar compilationLog = gl.getShaderInfoLog(fShader);\r\nconsole.log('Shader compiler log: ' + compilationLog);\r\n\r\nvar program = gl.createProgram();\r\ngl.attachShader(program, vShader);\r\ngl.attachShader(program, fShader);\r\ngl.linkProgram(program);\r\ngl.deleteShader(vShader);\r\ngl.deleteShader(fShader);\r\ngl.useProgram(program);\r\n\r\nvar screen_ratio_location = gl.getUniformLocation(program, \"screen_ratio\");\r\nvar position_location = gl.getAttribLocation(program, \"position\");\r\nvar resolution_location = gl.getUniformLocation(program, \"resolution\");\r\nvar playerPos_location = gl.getUniformLocation(program, \"playerPos\");\r\nvar playerFwd_location = gl.getUniformLocation(program, \"playerFwd\");\r\nvar playerUp_location = gl.getUniformLocation(program, \"playerUp\");\r\nvar playerRight_location = gl.getUniformLocation(program, \"playerRight\");\r\nvar time_location = gl.getUniformLocation(program, \"time\");\r\nvar fr_location = gl.getUniformLocation(program, \"fixed_radius\");\r\nvar mr_location = gl.getUniformLocation(program, \"min_radius\");\r\nvar fl_location = gl.getUniformLocation(program, \"folding_limit\");\r\nvar scale_location = gl.getUniformLocation(program, \"scale\");\r\nvar shadow_location = gl.getUniformLocation(program, \"shadow_count\");\r\nvar detail_location = gl.getUniformLocation(program, \"detail\");\r\ngl.uniform1f(fr_location, 1.9);\r\ngl.uniform1f(mr_location, .1);\r\ngl.uniform1f(fl_location, 1);\r\ngl.uniform1f(scale_location, -2.8);\r\ngl.uniform1f(detail_location, Math.pow(10, -4));\r\n\r\ngl.uniform2f(resolution_location, canvas.width, canvas.height);\r\ngl.uniform1i(shadow_location, 40);\r\nvar mx = Math.max(canvas.width, canvas.height);\r\ngl.uniform2f(screen_ratio_location, canvas.width / mx, canvas.height / mx);\r\n\r\nvar buffer = gl.createBuffer();\r\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]), gl.STATIC_DRAW);\r\ngl.enableVertexAttribArray(position_location);\r\ngl.vertexAttribPointer(position_location, 2, gl.FLOAT, false, 0, 0);\r\n\r\ncanvas.onmousedown = function (event) {\r\n    var x = event.clientX;\r\n    var y = event.clientY;\r\n    var rect = event.target.getBoundingClientRect();\r\n    if (rect.left <= x && rect.right > x &&\r\n        rect.top <= y && rect.bottom > y) {\r\n        lastX = x;\r\n        lastY = y;\r\n        mouseDown = true;\r\n    }\r\n}\r\ncanvas.onmouseup = function (event) {\r\n    mouseDown = false;\r\n}\r\nfunction degToRad(d) {\r\n    return d * Math.PI / 180;\r\n}\r\ncanvas.onmousemove = function (event) {\r\n    var x = event.clientX;\r\n    var y = event.clientY;\r\n    if (mouseDown) {\r\n        yawAngle += (x - lastX) / canvas.width * 400;\r\n        pitchAngle += (y - lastY) / canvas.height * 400;\r\n        pitchAngle = Math.max(Math.min(pitchAngle, 89.999), -89.999);\r\n    }\r\n    lastX = x;\r\n    lastY = y;\r\n}\r\n\r\nvar speed_range = document.getElementById(\"speed\");\r\ncanvas.onmousewheel = function (event) {\r\n    speed += Math.sign(event.wheelDelta);\r\n    speed = Math.max(Math.min(speed, 20), -40);\r\n    speed_range.value = Math.round(speed);\r\n}\r\nspeed_range.addEventListener('input', function () {\r\n    speed = parseInt(speed_range.value);\r\n});\r\ndocument.getElementById(\"fixed_radius\").addEventListener('input', function () {\r\n    gl.uniform1f(fr_location, parseFloat(document.getElementById(\"fixed_radius\").value));\r\n});\r\ndocument.getElementById(\"min_radius\").addEventListener('input', function () {\r\n    gl.uniform1f(mr_location, parseFloat(document.getElementById(\"min_radius\").value));\r\n});\r\ndocument.getElementById(\"folding_limit\").addEventListener('input', function () {\r\n    gl.uniform1f(fl_location, parseFloat(document.getElementById(\"folding_limit\").value));\r\n});\r\ndocument.getElementById(\"scale\").addEventListener('input', function () {\r\n    gl.uniform1f(scale_location, parseFloat(document.getElementById(\"scale\").value));\r\n});\r\ndocument.getElementById(\"detail\").addEventListener('input', function () {\r\n    gl.uniform1f(detail_location, Math.pow(10, -parseFloat(document.getElementById(\"detail\").value)));\r\n});\r\ndocument.getElementById(\"shadow\").addEventListener('input', function () {\r\n    gl.uniform1i(shadow_location, parseInt(document.getElementById(\"shadow\").value));\r\n});\r\n\r\nwindow.addEventListener(\"keydown\", onKeyDown, false);\r\nwindow.addEventListener(\"keyup\", onKeyUp, false);\r\n\r\nfunction onKeyDown(event) {\r\n    var keyCode = event.keyCode;\r\n    switch (keyCode) {\r\n        case 68: //d\r\n            move[0] = 1;\r\n            break;\r\n        case 83: //s\r\n            move[2] = -1;\r\n            break;\r\n        case 65: //a\r\n            move[0] = -1;\r\n            break;\r\n        case 87: //w\r\n            move[2] = 1;\r\n            break;\r\n    }\r\n}\r\n\r\nfunction onKeyUp(event) {\r\n    var keyCode = event.keyCode;\r\n\r\n    switch (keyCode) {\r\n        case 68: //d\r\n            move[0] = 0;\r\n            break;\r\n        case 83: //s\r\n            move[2] = 0;\r\n            break;\r\n        case 65: //a\r\n            move[0] = 0;\r\n            break;\r\n        case 87: //w\r\n            move[2] = 0;\r\n            break;\r\n    }\r\n}\r\n\r\nfunction movement(deltaTime) {\r\n\r\n    var fwd = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 0, 1);\r\n    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateX(fwd, fwd, [0, 0, 0], degToRad(-pitchAngle));\r\n    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateY(fwd, fwd, [0, 0, 0], degToRad(-yawAngle));\r\n    var right = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 0, 0);\r\n    var up = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 1, 0)\r\n    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.cross(right, up, fwd);\r\n    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.normalize(right, right);\r\n    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.cross(up, right, fwd);\r\n    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.normalize(up, up);\r\n\r\n\r\n    var rightMove = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();\r\n    var rSpeed = Math.pow(10, speed / 10);\r\n    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.scale(rightMove, right, move[0] * deltaTime * rSpeed);\r\n    var fwdMove = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();\r\n    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.scale(fwdMove, fwd, move[2] * deltaTime * rSpeed);\r\n    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.add(playerPos, playerPos, rightMove);\r\n    gl_matrix__WEBPACK_IMPORTED_MODULE_2__.add(playerPos, playerPos, fwdMove);\r\n\r\n    gl.uniform3f(playerUp_location, up[0], up[1], up[2]);\r\n    gl.uniform3f(playerRight_location, right[0], right[1], right[2]);\r\n    gl.uniform3f(playerFwd_location, fwd[0], fwd[1], fwd[2]);\r\n    gl.uniform3f(playerPos_location, playerPos[0], playerPos[1], playerPos[2]);\r\n}\r\n\r\n\r\n\r\nvar start = Date.now();\r\nvar lastFrame = start;\r\nfunction render() {\r\n    var current = Date.now();\r\n    var elapsed = current - lastFrame;\r\n    lastFrame = current;\r\n    gl.uniform1f(time_location, current - start);\r\n    movement(elapsed / 1000);\r\n\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n\r\n    requestAnimationFrame(render, canvas);\r\n}\r\nrender();\n\n//# sourceURL=webpack://fractals/./src/app.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/app.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;